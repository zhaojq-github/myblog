[TOC]



# Redis的缓存穿透及解决方法——布隆过滤器BloomFilter



## Redis概述：

Redis是一个开源的Key-Value存储系统，其中Value支持String、list、set、hash、zset五种数据结构，这些数据都支持push/pop、add/remove、取交集并集、排序等丰富的操作，并且这些操作都是原子性的。

与同为NoSQL型缓存数据库的memcached类似，Redis的数据都存在内存中，数据的运算都在内存中进行，不会发生IO，这也是Redis为什么这么快的一个原因；区别是Redis具备持久化方式，会周期性的把更新的数据写入磁盘（RDB）或者把修改操作追加写入记录文件中（AOF）。

也就是说，Redis的数据存放在内存中，但Redis也支持持久化将数据存入磁盘或文件。

Redis是单线程的，但是多任务并发时可以开启多个Redis，并且Redis支持主从同步，避免了宕机带来的影响，以及写时同步技术实现了数据读写分离（主机负责写入、从机负责读取）。

ps：Redis的特点是单线程+多路IO复用


## Redis的主要应用场景：

### （1）配合关系型数据库做高速缓存

针对对于高频次、热门访问的数据（热点数据），Redis基于内存可以有效避免IO；

另外对于分布式架构，可以做session分享。

### （2）因为Redis的持久化能力，可以利用多样性的数据结构存储特定的数据

例如通过list，得出最新的n个数据；利用有序集合zset进行排序，得出排行榜，topN；利用Expire对key设置时效性；

利用自增incr、decr可以实现计数器、秒杀；

利用set集合去重；利用list集合构建队列；利用pub、sub模式发布订阅消息系统。

## 缓存穿透及布隆过滤器
Redis的基于缓存，极大地提升了应用程序的性能和效率，特别是数据查询方面，但是也带来了一些问题，比如典型的

缓存穿透、缓存雪崩、缓存击穿。

本篇先讲缓存穿透及其解决办法。

### （1）缓存穿透（大量查询一个不存在的key）定义

缓存穿透，是指查询一个数据库中不一定存在的数据；

正常使用缓存查询数据的流程是，依据key去查询value，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。

如果每次都查询一个不存在value的key，由于缓存中没有数据，所以每次都会去查询数据库；

当对key查询的并发请求量很大时，每次都访问DB，很可能对DB造成影响；

并且由于缓存不命中，每次都查询持久层，那么也失去了缓存的意义。 

### （2）解决方法

#### 第一种是缓存层缓存空值

将数据库中的空值也缓存到缓存层中，这样查询该空值就不会再访问DB，而是直接在缓存层访问就行。

但是这样有个弊端就是缓存太多空值占用了更多的空间，可以通过给缓存层空值设立一个较短的过期时间来解决，例如60s。

#### 第二种是布隆过滤器

将数据库中所有的查询条件，放入布隆过滤器中，

当一个查询请求过来时，先经过布隆过滤器进行查，如果判断请求查询值存在，则继续查；如果判断请求查询不存在，直接丢弃。

##### 布隆过滤器原理

原理就是一个对一个key进行k个hash算法获取k个值，在比特数组中将这k个值散列后设定为1，然后查的时候如果特定的这几个位置都为1，那么布隆过滤器判断该key存在。

布隆过滤器可能会误判，如果它说不存在那肯定不存在，如果它说存在，那数据有可能实际不存在；

Redis的bitmap只支持2^32大小，对应到内存也就是512MB，误判率万分之一，可以放下2亿左右的数据，性能高，空间占用率及小，省去了大量无效的数据库连接。

因此我们可以通过布隆过滤器，将Redis缓存穿透控制在一个可容范围内。

参考文章：

[基于Redis的BloomFilter实战](https://blog.csdn.net/xf_87/article/details/51074642)

[层峦叠嶂——redis布隆过滤器](https://baijiahao.baidu.com/s?id=1611754128562106165&wfr=spider&for=pc)

## 布隆过滤器另一个用途——推荐去重

例如新闻客户端的推送去重功能，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。

实际上，如果历史记录存储在关系数据库里，去重就需要频繁地对数据库进行 exists 查询，当系统并发量很高时，数据库是很难扛住压力的。如果使用缓存把历史记录都放入缓存里，占用空间太大明显不现实，这个时候布隆过滤器就登场了，它就是专门用来解决这种去重问题的。它在起到去重的同时，在空间上还能节省 90% 以上，只是稍微有那么点不精确，也就是有一定的误判概率。

用户浏览记录存入数据库时，会在Filter上通过key的hash算法存储判断其是否存在，类似于数据存在数据库中，判断该数据是否存在的信息即元数据存放在BloomFilter中，避免了每次判断数据是否存在都要去数据库exist一遍；这样推送新闻时通过布隆过滤器判断，推送内容是否已经存在，如果存在则不推送，如果不存在则推送；

布隆过滤器可以准确过滤你已经看过的内容，没有看过的新内容，可能由于误判率过滤掉极小的一部分，这样就可以保证推荐给用户的都是无重复的。

 

原文链接：https://blog.csdn.net/wx1528159409/article/details/88357728