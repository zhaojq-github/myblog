[TOC]

# JVM相关笔试面试题目

### **1. 类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序**

先静态、先父后子。

先静态：父静态 > 子静态

优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数

一个类的实例化过程：

父类中的static代码块，当前类的static

顺序执行父类的普通代码块

父类的构造函数

子类普通代码块

子类（当前类）的构造函数，按顺序执行。

子类方法的执行

### **2.Java 8的内存分代改进**

从永久代到元空间，在小范围自动扩展永生代避免溢出

### **3.JVM垃圾回收机制，何时触发MinorGC等操作**

分代垃圾回收机制：不同的对象生命周期不同。把不同生命周期的对象放在不同代上，不同代上采用最合适它的垃圾回收方式进行回收。

JVM中共划分为三个代：年轻代、年老代和持久代，

年轻代：存放所有新生成的对象；

年老代：在年轻代中经历了N次垃圾回收仍然存活的对象，将被放到年老代中，故都是一些生命周期较长的对象；

持久代：用于存放静态文件，如Java类、方法等。

新生代的垃圾收集器命名为“minor gc”，老生代的GC命名为”Full Gc 或者Major GC”.其中用System.gc()强制执行的是Full Gc.

判断对象是否需要回收的方法有两种：

**引用计数**

当某对象的引用数为0时，便可以进行垃圾收集。

**对象引用遍历**

果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集。在对象遍历阶段，gc必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象。

触发GC（Garbage Collector）的条件：

GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。

Java堆内存不足时，GC会被调用。

### **4.Eden和Survivor的比例分配等**

默认比例8:1。

大部分对象都是朝生夕死。

复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。

### **5.对Java内存模型的理解，以及其在并发中的应用**

Java内存模型的主要目标: 定义程序中各个变量的访问规则。

Java线程之间的通信由Java内存模型（本文简称为JMM）控制。

所有变量的存储都在主内存，每条线程还都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存完成，而不能直接读取主内存中的变量。

不同的线程直接无法访问对方工作内存中的变量，线程间变量的传递均需要通过主内存来完成。

线程间通信：

首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。

然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

### **6. g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择**

CMS收集器：一款以获取最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的，分为4个步骤：初始标记、并发标记、重新标记、并发清除。

G1收集器：面向服务端应用的垃圾收集器，过程：初始标记；并发标记；最终标记；筛选回收。整体上看是“标记-整理”，局部看是“复制”，不会产生内存碎片。

吞吐量优先的并行收集器：以到达一定的吞吐量为目标，适用于科学技术和后台处理等。

响应时间优先的并发收集器：保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。

### **7. jvm中一次完整的GC流程（从ygc到fgc）是怎样的**

对象优先在新生代区中分配，若没有足够空间，Minor GC；

大对象（需要大量连续内存空间）直接进入老年态；长期存活的对象进入老年态。如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。

### **8.tomcat结构，类加载器流程**

在Tomcat目录结构中，有3组目录（“/common/*”、“/server/*”和“/shared/*”）可以存放Java类库，另外还可以加上Web应用程序自身的目录“/WEB-INF/*”，一共4组，把Java类库放置在这些目录中的含义分别如下：

①放置在/common目录中：类库可被Tomcat和所有的Web应用程序共同使用。

②放置在/server目录中：类库可被Tomcat使用，对所有的Web应用程序都不可见。

③放置在/shared目录中：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。

④放置在/WebApp/WEB-INF目录中：类库仅仅可以被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见。

为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现，其关系如下图所示。

上图中灰色背景的3个类加载器是JDK默认提供的类加载器，这3个加载器的作用已经介绍过了。而CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载/common/*、/server/*、/shared/*和/WebApp/WEB-INF/*中的Java类库。

其中WebApp类加载器和Jsp类加载器通常会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。

从图中的委派关系中可以看出，CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。

而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。

### **9.说一下强引用、软引用、弱引用、虚引用以及他们之间和gc的关系**

**强引用**：new出的对象之类的引用，只要强引用还在，永远不会回收

**软引用**：引用但非必须的对象，内存溢出异常之前，回收

**弱引用**：非必须的对象，对象能生存到下一次垃圾收集发生之前。

**虚引用**：对生存时间无影响，在垃圾回收时得到通知。





https://www.toutiao.com/a6625773467436319245/?tt_from=android_share&utm_campaign=client_share&timestamp=1542719915&app=news_article&iid=51078319704&utm_medium=toutiao_android&group_id=6625773467436319245