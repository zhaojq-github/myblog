

[TOC]

 

# javascript浮点数计算为什么不精确 0.3-0.2 不等于0.1的解决方案

发表于 2016-11-17 | 分类于 [计算机原理 ](https://brooch.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/)|  763

> 其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_

前几几几几天，在微博上看到[寇胖](http://weibo.com/u/1778942741)转了一个关于浮点数计算的[微博](http://weibo.com/1996814695/DC0c6iAVD)，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~*

## 结论

先说结论，嫌又臭又长的看到这里就可以了:

- 浮点数计算不精确并不是bug，因为标准就是这样的。
- 原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。
- 解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用[big.js](http://mikemcl.github.io/big.js/)解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。

## 小数算不准，真的是js的锅吗？

说到这个问题，其实这是两个锅，js计算不准确不止会出现在小数的计算上，还会出现在大整数计算上，可以运行下面两行代码查看问题的具体表现：

```
0.1 + 0.2 == 0.3; // false
9999999999999999 + 2 == 10000000000000001; // false
```

当然，这个锅肯定不是javascript背。事实上，使用了IEEE 754 标准来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。

例如在 Java 中，要想算准浮点数，同样不能直接计算，需要使用 BigDecimal 类来进行相应的处理。

当然，javascript也并没有落后于其他语言。ECMAScript 规范中已有 [decimal ](http://wiki.ecmascript.org/doku.php?id=proposals:decimal)类型的提案了，但目前尚未被正式采纳。

## 为什么不算准？

要解释这个问题，就得从10进制与2进制的转换说起。

众所周知，计算机做运算是使用二级制的。所以其实咱们在程序中做10进制运算，都是要转换为2进制再进行计算的。10进制整数转换为2进制的方法可能大家都知道：

> **除以2，商继续除以2，得到0为止，将余数逆序排列**
> 例如：
> 22 / 2 11 余 0
> 11 / 2 5 余 1
> 5 / 2 2 余 1
> 2 / 2 1 余 0
> 1 / 2 0 余 1
> 所以22的的二进制是10110

那10进制小数转换为2进制的方法呢？

> **乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列**
> 0.8125 x 2 1.625 取 1
> 0.625 x 2 1.25 取 1
> 0.25 x 2 0.5 取 0
> 0.5 x 2 1.0 取 1
> 所以0.8125的二进制是0.1101

那么问题就来了，比如你想计算10进制0.2的2进制：

> 0.2 x 2 0.4
> 0.4 x 2 0.8
> 0.8 x 2 1.6
> 0.6 x 2 1.2
> 0.2 x 2 0.4
> ……

发现了吗？它乘不尽，是无限循环的……

而 javascript 使用64位双精度浮点数存储数字，类似科学计数法，其中1位用来存储符号，11位用来存储指数值，52位用来存储尾数值（真正的数字），当计算的结果的二进制有效位数超过 52 位时，就会出现精度丢失的问题……

大整数计算的原因也是一样，有效位数超过 52位时，精度就会丢失

这就解释了下面这种情况：

> 十进制 0.1 的二进制为 0.0 0011 0011 0011 … （循环 0011）
> 十进制 0.2 的二进制为 0.0011 0011 0011 … （循环 0011）
>
> 0.1 + 0.2 相加可表示为：
> e = -4; m = 1.10011001100…1100（52 位）
> \+ e = -3; m = 1.10011001100…1100（52 位）
> -——————————————–
> e = -3; m = 0.11001100110…0110
> \+ e = -3; m = 1.10011001100…1100
> -——————————————–
> e = -3; m = 10.01100110011…001
> -——————————————–
> = 0.01001100110011…001
> = 0.30000000000000004（十进制）

但是0.05和0.2用二进制都无法精确表达，0.05 + 0.2 却不会计算错误，0.2 + 0.7 会计算错误，1.2 +1.7 又不会，这又是为什么？

具体的原因我并没有找到相关的资料……

貌似这和 IEEE 754 的舍入模式有关系。

IEEE 754 采用的是最近舍入模式，和我们最熟悉的是四舍五入模式有些许不同，也是比较容易引起误解的地方之一。举例比较如下：

> 最近舍入模式：Round(0.5) = 0; Round(1.5) = 2; Round(2.5) = 2;
>
> 四舍五入模式：Round(0.5) = 1; Round(1.5) = 2; Round(2.5) = 3;

既当有两个最接近的可表示的值时首选“偶数”值。

具体的原因我会再调查调查，有了新的资料再补充到这里。

## 如何解决这个问题？

当然，问题的解决方法其实也已经有前人跟咱们铺好路了，毕竟这个在问题在编程领域里其实是个挺常见的问题……

网上的解决办法五花八门，总的原则就是逐位运算。我推荐 github 上 [MikeMcl](https://github.com/MikeMcl) 开发的 [big.js](http://mikemcl.github.io/big.js/) 。这个库不尽支持基础运算，而且还支持各种函数运算和比较运算，相当全面呢。实现上，是将数字按照科学计数法解析成一个包含正负符号、指数、尾数的对象，再做运算。例子就不写了，它的文档很全，而且简单易懂。

有趣的是，这个作者除了 big.js 还开发了另两个计算库 bignumber.js 和 decimal.js，三个库的侧重点不一样，关于这三个的对比，有兴趣的话可以看作者自己写的wiki [What is the difference between big.js, bignumber.js and decimal.js?](https://github.com/MikeMcl/big.js/wiki)

## 相关文章:

1. [浮点数为什么不精确？](http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513140&idx=1&sn=565517e977ac56904305a4a9f9d65012#rd)
2. [JavaScript超大整数加法](http://www.cnblogs.com/maplejan/p/3893545.html)
3. [JavaScript 中小数和大整数的精度丢失](http://demon.tw/copy-paste/javascript-precision.html)
4. [IEEE 754 浮点数的表示精度探讨](http://www.cnblogs.com/bossin/archive/2007/04/08/704567.html)
5. [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754)







https://brooch.me/2016/11/17/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE/