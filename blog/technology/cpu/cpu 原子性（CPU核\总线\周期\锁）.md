[TOC]



# cpu 原子性（CPU核\总线\周期\锁）



如何看Linux是多少位的CPU

uname -an

## **CPU寻址**

CPU的位宽一般是以 min{ALU位宽、通用寄存器位宽、数据总线位宽}决定的！也就是说CPU由ALU、通用寄存器、数据总线三者之中最少的位宽决定！**所以CPU位宽与其寻址能力并不是挂钩的！32位CPU指的是上述三个都是32位。和地址总线没关系。地址总线觉得了寻址的范围，数据总线和寄存器（SI\DI等）决定了可寻址的能力。**

32 位 x86 CPU 包括 8 个通用寄存器。64 位 x64 处理器有 16 个寄存器。 
64 位处理器（以及为它们编写的应用程序和操作系统）可以更有效地处理数据，每个时钟周期可以移动更多信息。

## **时钟周期、总线周期和指令周期**

**相关概念：**
时钟周期、总线周期和指令周期
1.时钟周期：微处理器执行指令的最小时间单位，又称T状态。它通常与微机的主频有关。
2.总线周期：CPU对存储器或I/O端口完成一次读/写操作所需的时间。如8086微处理器的基本**总线周期由四个时钟周期**T1～T4组成，80486微处理器的基本总线周期由T1和T2两个时钟周期组成。当外设速度较慢时，可插入等待周期Tw。
3.指令周期：CPU执行一条指令所需要的时间。**指令周期由若干个总线周期组成**，不同指令执行的时间不同。同一功能的指令，在寻址方式不同时，所需要的时间也不同。

 

详细解释如下：

CPU每取出一条指令并执行这条指令，都要完成一系列的操作，这一系列操作所需要的时间通常叫做一个指令周期。换言之指令周期是取出一条指令并执行这条指令的时间。由于各条指令的操作功能不同，因此各种指令的指令周期是不尽相同的。例如一条加法指令的指令周期同一条乘法指令的指令周期是不相同的。 指令周期常常用若干个CPU周期数来表示，CPU周期也称机器周期。指令不同，所需的机器周期数也不同。对于一些简单的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。通常含一个机器周期的指令称为**单周期指令**，包含两个机器周期的指令称为**双周期指令**。
1.微处理器是在时钟信号CLK控制下按节拍工作的。8086/8088系统的时钟频率为4.77MHz，每个时钟周期约为200ns。
2.由于存贮器和I/O端口是挂接在总线上的，CPU对存贮器和I/O接口的访问，是通过总线实现的。通常把CPU通过总线对微处理器外部（存贮器或 I/O接口）进行一次访问所需时间称为一个总线周期。一个总线周期一般包含4个时钟周期，这4个时钟周期分别称4个状态即T1状态、T2状态、T3状态和 T4状态。
一个CPU周期时间有包含若干个时钟周期。时钟周期定义为时钟脉冲的倒数（可以这样来理解，时钟周期就是单片机外接晶振的倒数，例如12M的晶振，它的时间周期就是1/12μs），是计算机中最基本的、最小的时间单位。
在一个时钟周期内，CPU仅完成一个最基本的动作。由于时钟脉冲是计算机的基本工作脉冲，它控制着计算机的工作节奏（使计算机的每一步都统一到它的步调上来）。显然，对同一种机型的计算机，时钟频率越高，计算机的工作速度就越快。但是，由于不同的计算机硬件电路和器件的不完全相同，所以其所需要的时钟周频率范围也不一定相同。我们学习的 8051单片机的时钟范围是1.2MHz-12MHz。
一个机器周期包含六个状态周期（用S表示）。一个状态周期有两个节拍（用P1、P2表示）。
8051系列单片机的一个机器周期同6 个S周期（状态周期）组成。也就是说一个机器周期=6个状态周期=12个振荡周期（即时钟周期）。
总结一下，它们之间的关系就是，指令周期由若干个机器周期组成，总线周期一般由4个时钟周期组成，6个震荡周期。
机器周期和总线周期 并无明确的相互包含的关系。机器周期指的是完成一个基本操作的时间，这个基本操作有时可能包含总线读写，因而包含总线周期，但是有时可能与总线读写无关。
指令周期：是CPU的关键指标，指取出并执行一条指令的时间。一般以机器周期为单位，分单指令执行周期、双指令执行周期等。现在的处理器的大部分指令（ARM、DSP）均采用单指令执行周期。
机器周期：完成一个基本操作的时间单元，如取指周期、取数周期。
时钟周期：CPU的晶振频率的倒数的。(fantaxy:晶振一次需要的时间)
一个机器周期一般是一条指令花费的时间，也有些是2个机器周期的指令，DJNZ，是双周期指令。
周期：就是时间，完成一次任务的时间
**时钟周期：**这个名字的英文clockcycle; clock period；时钟是用来计时的，是一个基本单位；在计算机中，cpu的晶振时间就是一个最最基本的单位，因此时钟周期很基本，别的周期都用它来参考！

## **锁的机制：**

锁其实就是锁总线。

在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀"LOCK"，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的**电位拉低**，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的。

第二个机制是通过缓存锁定保证原子性。在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。

所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的**缓存一致性机制**来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在例1中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。
但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

原子问题：

分为两种，总体来说就是非单一指令导致的。

一种是32位机写64位数据，需要写两次，有中间状态。

另外是多指令，参考http://write.blog.csdn.net/postedit/42716259



https://blog.csdn.net/duxingxia356/article/details/42716433